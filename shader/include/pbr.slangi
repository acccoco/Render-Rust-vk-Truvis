#pragma once
#include "bindless.slangi"
#include "common.slangi"
#include "sample/random.slangi"
#include "sample/sample.slangi"

struct SpecularBrdf
{
    float3 f0;
    float roughness;
    float3 normal;
    float3 view;
    float3 h;

    float3 light;
    float vdoth;
    float ndotl;
    float ndotv;
    float ndoth;

    float D;
    float3 F;
    float V;

    /// @param f0
    /// @param roughness
    /// @param normal
    /// @param view 观察方向，从物体到相机
    /// @param light 光照方向，从物体到光源
    __init(float3 f0, float roughness, float3 normal, float3 view, float3 h)
    {
        this.f0 = f0;
        this.roughness = roughness;
        this.normal = normal;
        this.view = view;
        this.h = h;

        this.light = normalize(2.f * saturate(dot(view, h)) * h - view);
        this.vdoth = saturate(dot(view, h));
        this.ndotl = saturate(dot(normal, light));
        this.ndotv = saturate(dot(normal, view));
        this.ndoth = saturate(dot(normal, h));

        this.D = this.ndf_ggx();
        this.F = this.fresnel_schlick();
        this.V = this.visibility_smith_ggx_correlated();
    }

    float3 brdf()
    {
        return this.F * this.D * this.V;
    }

    float ndf_ggx()
    {
        // 注意，当粗糙度接近 0 时，可能导致除零错误
        const float a = ndoth * roughness;
        const float k = roughness / max(1.f - this.ndoth * this.ndoth + a * a, 1e-7f);
        return k * k * (1.f / M_PI);
    }

    float3 fresnel_schlick()
    {
        const float f = pow(1.f - this.vdoth, 5.f);
        return f + this.f0 * (1.f - f);
    }

    float visibility_smith_ggx_correlated()
    {
        const float a2 = this.roughness * this.roughness;
        const float ggx_v = this.ndotl * sqrt(this.ndotv * this.ndotv * (1.f - a2) + a2);
        const float ggx_l = this.ndotv * sqrt(this.ndotl * this.ndotl * (1.f - a2) + a2);
        return 0.5f / max(ggx_v + ggx_l, 1e-7f);
    }

    /// 基于 NDF 进行采样，得到的是半程向量 H
    /// pdf = D * NdotH / (4 * NdotV)
    static float3 ggx_sample(inout uint rand_seed, const float roughness, const float3 normal)
    {
        float3 tangent, bitangent;
        Sample::create_local_coord(normal, tangent, bitangent);

        const float2 rand_val = float2(clamp(Random::rnd(rand_seed), 0.001f, 0.999f), Random::rnd(rand_seed));
        // GGX NDF sampling
        const float a2 = roughness * roughness;
        const float denominator = (a2 - 1.f) * rand_val.x + 1.f;
        const float cos_theta_h = saturate(sqrt(max(0.0f, (1.0 - rand_val.x) / max(1e-7f, denominator))));
        const float sin_theta_h = sqrt(max(0.0f, 1.0f - cos_theta_h * cos_theta_h));
        const float phi_h = rand_val.y * M_PI * 2.0f;

        // Get our GGX NDF sample (i.e., the half vector)
        return tangent * (sin_theta_h * cos(phi_h)) +
               bitangent * (sin_theta_h * sin(phi_h)) +
               normal * cos_theta_h;
    }

    float ggx_pdf()
    {
        return this.D * this.ndoth / max(4.f * this.vdoth, 1e-7f);
    }

    float3 brdf_with_pdf()
    {
        return this.F * this.V * (4.f * this.vdoth) / max(this.ndoth, 1e-7f);
    }

    float get_ndotl()
    {
        return this.ndotl;
    }
};

struct DiffuseBrdf
{

    static float3 brdf()
    {
        // TODO
        return float3(1.f, 1.f, 1.f) / M_PI;
    }

    static float3 cos_sample(inout Random rand, float3 normal)
    {
        const float3 local_dir = Sample::get_cos_hemisphere_sample(rand.rng_stage);
        float3 tangent, bitangent;
        Sample::create_local_coord(normal, tangent, bitangent);
        return normalize(local_dir.x * tangent + local_dir.y * bitangent + local_dir.z * normal);
    }
}
