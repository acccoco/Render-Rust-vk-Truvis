#pragma once

#include "share/ptr.slangi"
#include "share/irradiance_cache_data.slangi"

namespace ic
{

// ============================================================================
// 常量定义
// ============================================================================

/// 每个 cell 的大小（世界单位）
const static float CELL_SIZE = 16.0f;

/// 有效采样数阈值，超过此值后更新权重固定
const static uint VALID_SAMPLE_COUNT = 64;

/// 最小权重阈值，低于此值认为查找失败
const static float MIN_WEIGHT_THRESHOLD = 0.001f;

/// 法线相似度阈值（cos 值），约 25° 夹角
const static float NORMAL_THRESHOLD = 0.9f;

/// 默认 entry 半径
const static float DEFAULT_RADIUS = CELL_SIZE * 1.6f;

/// weight = Radius / (100 * Dist + Radius)
/// Dist = (1 - weight) / (100 * weigt) * Radius

/// 大约 0.8R
const static float IC_LOOKUP_THRESHOLD = 0.0123f;

/// 大约 0.4R
const static float IC_UPDATE_THRESHOLD = 0.0244f;

/// 空间哈希使用的质数
const static uint HASH_PRIME_1 = 73856093u;
const static uint HASH_PRIME_2 = 19349663u;
const static uint HASH_PRIME_3 = 83492791u;

// ============================================================================
// 辅助函数
// ============================================================================

/// 世界坐标转换为 cell 坐标
int3 world_to_cell(float3 world_pos)
{
    return int3(floor(world_pos / CELL_SIZE));
}

/// 3D 空间哈希，使用质数乘法 + XOR
uint spatial_hash(int3 cell_coord)
{
    return (uint(cell_coord.x) * HASH_PRIME_1) ^
        (uint(cell_coord.y) * HASH_PRIME_2) ^
        (uint(cell_coord.z) * HASH_PRIME_3);
}

/// 获取 cell 对应的 bucket 索引
uint get_bucket_index(int3 cell_coord)
{
    return spatial_hash(cell_coord) % BUCKET_NUM;
}

/// 判断当前表面是否满足 diffuse 条件（用于 IC 查询）
/// @param info 命中信息
/// @return true 表示满足 diffuse 条件
bool is_diffuse_surface(float roughness, float metallic)
{
    // return info.roughness >= rt::IC_DIFFUSE_ROUGHNESS_THRESHOLD &&
    //     info.metallic < rt::IC_DIFFUSE_METALLIC_THRESHOLD;
    return roughness > 0.6f &&
        metallic < 0.6f;
}

/// 计算 entry 对查询点的权重
/// 基于 Ward 的 1/R 权重公式，结合法线相似度
/// @param query_pos 查询位置
/// @param query_normal 查询法线
/// @param entry_pos entry 位置
/// @param entry_normal entry 法线
/// @param entry_radius entry 影响半径
/// @return 权重值 [0, 1.0]，0 表示无效
float compute_entry_weight(
    float3 query_pos,
    float3 query_normal,
    float3 entry_pos,
    float3 entry_normal,
    float entry_radius
)
{
    // 检查法线相似度
    float normal_dot = dot(query_normal, entry_normal);
    if (normal_dot < NORMAL_THRESHOLD)
    {
        return 0.0f;
    }

    // 计算距离
    float3 diff = query_pos - entry_pos;
    float dist_sq = dot(diff, diff);
    float radius_sq = entry_radius * entry_radius;

    // 距离超出影响半径
    if (dist_sq > radius_sq)
    {
        return 0.0f;
    }

    // Ward 权重公式: w = 1 / (dist / radius + epsilon)
    // 加入法线因子进行调制
    float dist = sqrt(dist_sq);
    float dist_factor = 1.0f / (dist / entry_radius + 0.01f);
    float normal_factor = (normal_dot - NORMAL_THRESHOLD) / (1.0f - NORMAL_THRESHOLD);

    // 这里的 10.f 和上方的 0.1f 是对应的，将权重归一化到 [0, 1] 范围内
    return dist_factor * normal_factor / 100.f;
}

// ============================================================================
// Irradiance Cache 主结构
// NOTE: 虽然技术名称为 "Irradiance Cache"，但实际存储的是
//       outgoing radiance = irradiance * (rho / pi)，即 diffuse 表面的出射辐射
//       这样在查询时可以直接累加，无需再乘以 diffuse albedo
// ============================================================================

namespace fn
{
/// 查询 Irradiance Cache
/// @param position 查询位置
/// @param normal 查询法线
/// @param out_radiance [out] 输出插值后的 outgoing radiance
/// @param weight [out] 输出总权重
/// @param max_weight_entry_index [out] 输出最大权重的 entry 索引，用于后续 update
/// @param max_weight [out] 输出最大权重值
/// @return 如果找到有效的缓存，返回 true
bool lookup(
    Table* hash_table,
    EntryPool* entry_pool,
    float3 position,
    float3 normal,
    out float3 out_radiance,
    out float weight,
    out uint max_weight_entry_index,
    out float max_weight
)
{
    // 初始化输出
    out_radiance = float3(0.0f);
    weight = 0.0f;
    max_weight_entry_index = 0xFFFFFFFF;
    max_weight = 0.0f;

    float3 weighted_radiance = float3(0.0f);
    float total_weight = 0.0f;

    // 获取当前位置所在的 cell
    int3 center_cell = world_to_cell(position);

    // 用于去重已访问的 bucket（避免哈希碰撞导致同一 bucket 被多次遍历）
    // 使用位掩码记录已访问的 bucket，最多支持 27 个不同的 bucket
    uint visited_bucket_indices[27];
    uint visited_count = 0;

    // 遍历 3x3x3 邻域
    for (int idx = 0; idx < 27; idx++)
    {
        int dz = idx / 9 - 1;
        int dy = (idx / 3) % 3 - 1;
        int dx = idx % 3 - 1;
        int3 neighbor_cell = center_cell + int3(dx, dy, dz);

        uint bucket_idx = get_bucket_index(neighbor_cell);

        // 检查该 bucket 是否已被访问（避免哈希碰撞导致重复计算）
        bool already_visited = false;
        for (uint v = 0; v < visited_count; v++)
        {
            if (visited_bucket_indices[v] == bucket_idx)
            {
                already_visited = true;
                break;
            }
        }
        if (already_visited)
        {
            continue;
        }
        visited_bucket_indices[visited_count] = bucket_idx;
        visited_count++;

        // 获取 bucket
        Bucket bucket = hash_table->buckets[bucket_idx];
        uint entry_count = min(bucket.entry_count, MAX_ENTRY_IN_BUCKET);

        // 遍历 bucket 内的所有 entry
        for (uint i = 0; i < entry_count; i++)
        {
            uint entry_idx = bucket.entry_indices[i];

            // 边界检查
            if (entry_idx >= MAX_ENTRY_NUM)
            {
                continue;
            }

            // 获取 entry 数据
            float3 entry_pos = entry_pool->positions[entry_idx].xyz;
            float3 entry_normal = entry_pool->normals[entry_idx].xyz;
            float3 entry_radiance = entry_pool->radiances[entry_idx].xyz;
            float entry_radius = entry_pool->radius[entry_idx];

            // 计算权重
            float w = compute_entry_weight(
                position, normal,
                entry_pos, entry_normal,
                entry_radius
            );

            if (w > 0.0f)
            {
                weighted_radiance += entry_radiance * w;
                total_weight += w;

                // 记录最大权重的 entry
                if (w > max_weight)
                {
                    max_weight = w;
                    max_weight_entry_index = entry_idx;
                }
            }
        }
    } 

    // 检查是否找到有效缓存
    if (total_weight > MIN_WEIGHT_THRESHOLD &&
        weighted_radiance.x >= 0.0f &&
        weighted_radiance.y >= 0.0f &&
        weighted_radiance.z >= 0.0f)
    {
        out_radiance = weighted_radiance / total_weight;
        weight = total_weight;
        return true;
    }

    return false;
}

/// 更新现有 entry 的 outgoing radiance
/// 使用增量移动平均，权重基于 sample count 衰减
/// @param entry_idx 要更新的 entry 索引
/// @param new_radiance 新的 outgoing radiance 样本
static void update(
    EntryPool* entry_pool,
    uint entry_idx,
    float3 position,
    float3 normal,
    float3 new_radiance
)
{
    // 边界检查
    if (entry_idx >= MAX_ENTRY_NUM)
    {
        return;
    }

    // 检查 new_radiance 是否有效（防止 NaN/Inf 污染缓存）
    float max_new = max(new_radiance.x, max(new_radiance.y, new_radiance.z));
    if (isnan(max_new) || isinf(max_new) || max_new > 1000.f)
    {
        return;
    }

    // 获取当前采样数
    uint current_count = entry_pool->sample_counts[entry_idx];

    // 计算更新权重：使用简单的指数移动平均
    // 采样数越多，新样本的权重越小
    uint effective_count = min(current_count + 1, VALID_SAMPLE_COUNT);
    float update_weight = 1.0f / float(effective_count);

    // 增量平均更新
    float3 old_radiance = entry_pool->radiances[entry_idx].xyz;
    entry_pool->radiances[entry_idx] = float4(lerp(old_radiance, new_radiance, update_weight), 0.0f);

    // 递增采样计数（使用原子操作）
    InterlockedAdd(entry_pool->sample_counts[entry_idx], 1u);
}

/// 插入新的 entry 到 Irradiance Cache
/// @param position entry 位置
/// @param normal entry 法线
/// @param radiance 初始 outgoing radiance
/// @return 成功返回 true，失败（entry 池满）返回 false
static bool insert(
    Table* hash_table,
    EntryPool* entry_pool,
    float3 position,
    float3 normal,
    float3 radiance
)
{
    // 检查 radiance 是否有效（防止 NaN/Inf 污染缓存）
    float max_rad = max(radiance.x, max(radiance.y, radiance.z));
    if (isnan(max_rad) || isinf(max_rad) || max_rad > 1000.f || max_rad < 0.001f)
    {
        return false;
    }

    // 原子分配新 entry 索引
    uint entry_idx;
    InterlockedAdd(entry_pool->entry_count, 1u, entry_idx);

    // 检查是否超出最大 entry 数
    if (entry_idx >= MAX_ENTRY_NUM)
    {
        // 回滚 entry_count
        InterlockedAdd(entry_pool->entry_count, -1);
        return false;
    }

    // 初始化 entry 数据
    entry_pool->positions[entry_idx] = float4(position, 0.0f);
    entry_pool->normals[entry_idx] = float4(normal, 0.0f);
    entry_pool->radiances[entry_idx] = float4(radiance, 0.0f);
    entry_pool->radius[entry_idx] = DEFAULT_RADIUS;
    entry_pool->sample_counts[entry_idx] = 1u;

    // 获取对应的 bucket
    int3 cell_coord = world_to_cell(position);
    uint bucket_idx = get_bucket_index(cell_coord);

    // 原子分配 bucket 内的 slot
    uint slot;
    InterlockedAdd(hash_table->buckets[bucket_idx].entry_count, 1u, slot);

    // 使用环形缓冲区策略：当 bucket 满时替换旧的 entry
    // slot % MAX_ENTRY_IN_BUCKET 确保索引在有效范围内
    uint actual_slot = slot % MAX_ENTRY_IN_BUCKET;
    
    // 使用原子交换确保写入对其他线程可见
    // 注意：这里仍存在短暂的竞态窗口，但原子操作保证了写入的原子性
    uint old_entry_idx;
    InterlockedExchange(hash_table->buckets[bucket_idx].entry_indices[actual_slot], entry_idx, old_entry_idx);

    return true;
}
};

}
