/// @file gbuffer.slangi
/// @brief GBuffer 写入辅助函数
///
/// GBuffer 布局：
/// - GBufferA (R16G16B16A16_SFLOAT): normal.xyz + roughness
/// - GBufferB (R16G16B16A16_SFLOAT): world_position.xyz + linear_depth
/// - GBufferC (R8G8B8A8_UNORM): albedo.rgb + metallic

#pragma once

#include "share/pass/rt.slangi"

namespace gbuffer
{

// ============================================================================
// 常量定义
// ============================================================================

/// 默认线性深度（用于 miss 情况）
static const float DEFAULT_LINEAR_DEPTH = 10000.0f;

// ============================================================================
// GBuffer 数据结构
// ============================================================================

/// GBuffer 数据（用于收集首次命中信息）
struct GBufferData
{
    float3 normal;      ///< 世界空间法线
    float roughness;    ///< 粗糙度

    float3 position;    ///< 世界空间位置
    float linear_depth; ///< 线性深度（光线 t 值）

    float3 albedo;      ///< 基础颜色（漫反射颜色）
    float metallic;     ///< 金属度
};

// ============================================================================
// GBuffer 写入函数
// ============================================================================

/// 从命中信息构建 GBuffer 数据
/// @param position 世界空间命中位置
/// @param normal 世界空间法线（应为 forward_normal）
/// @param linear_depth 线性深度（光线 t 值）
/// @param albedo 基础颜色
/// @param metallic 金属度
/// @param roughness 粗糙度
/// @return 填充好的 GBuffer 数据
GBufferData make_gbuffer_data(
    float3 position,
    float3 normal,
    float linear_depth,
    float3 albedo,
    float metallic,
    float roughness
)
{
    GBufferData data;
    data.position = position;
    data.normal = normal;
    data.linear_depth = linear_depth;
    data.albedo = albedo;
    data.metallic = metallic;
    data.roughness = roughness;
    return data;
}

/// 写入 GBuffer（命中情况）
/// @param thread_id 当前像素坐标
/// @param data GBuffer 数据
void write_gbuffer_hit(uint2 thread_id, GBufferData data)
{
    // GBufferA: normal.xyz + roughness
    rt::gbuffer_a.Store(thread_id, float4(data.normal, data.roughness));

    // GBufferB: world_position.xyz + linear_depth
    rt::gbuffer_b.Store(thread_id, float4(data.position, data.linear_depth));

    // GBufferC: albedo.rgb + metallic
    rt::gbuffer_c.Store(thread_id, float4(data.albedo, data.metallic));
}

/// 写入 GBuffer（miss 情况）
/// @param thread_id 当前像素坐标
/// @note miss 时写入默认值：depth = DEFAULT_LINEAR_DEPTH, 其他为 0
void write_gbuffer_miss(uint2 thread_id)
{
    // GBufferA: normal = (0,0,0), roughness = 0
    rt::gbuffer_a.Store(thread_id, float4(0.0f, 0.0f, 0.0f, 0.0f));

    // GBufferB: position = (0,0,0), depth = DEFAULT_LINEAR_DEPTH
    rt::gbuffer_b.Store(thread_id, float4(0.0f, 0.0f, 0.0f, DEFAULT_LINEAR_DEPTH));

    // GBufferC: albedo = (0,0,0), metallic = 0
    rt::gbuffer_c.Store(thread_id, float4(0.0f, 0.0f, 0.0f, 0.0f));
}

} // namespace gbuffer
